1 rakuten tokyo engineer java web api
2 rakuten tokyo engineer java web api python
3 rakuten tokyo engineer data ruby python

company location postion = clp
other = desp

map (key, value)

key = hash(rakuten+tokyo+engineer) = 0x123
value = set of hash = [0x1, 0x2, 0x3], [0x1, 0x2, 0x3, 0x4], [0x5, 0x6, 0x7] 

first round
- create index map (index, {md5(clp),md5(desp)})
- find 100 top most pattern of clp = map(md5(clp),occurance) -- or using threshold -- O(n)
- in each of 100 top clp, find top 100 desp = map(md5(desp),occurrance) -- or using threshold
- now have 100x100 pattern of most occurance of clp x desp
- start categorize the job from index 1 to all --> map(pattern,count)

Links:
String vs Int key
http://jacksondunstan.com/articles/2527

Super charging your HashMaps
http://www.javaranch.com/journal/2008/08/supercharging-your-hashmaps.html

Java collection big O
http://javadevelopersenior.com/blog/wp-content/uploads/2013/05/java_collections.pdf

Big o cheat sheet
http://bigocheatsheet.com/

Java memory optimization
http://java-performance.info/overview-of-memory-saving-techniques-java/

For LinkedList<E>

get(int index) is O(n)
add(E element) is O(1)
add(int index, E element) is O(n)
remove(int index) is O(n)
Iterator.remove() is O(1) <--- main benefit of LinkedList<E>
ListIterator.add(E element) is O(1) <--- main benefit of LinkedList<E>

For ArrayList<E>

get(int index) is O(1) <--- main benefit of ArrayList<E>
add(E element) is O(1) amortized, but O(n) worst-case since the array must be resized and copied
add(int index, E element) is O(n - index) amortized, but O(n) worst-case (as above)
remove(int index) is O(n - index) (i.e. removing last is O(1))
Iterator.remove() is O(n - index)
ListIterator.add(E element) is O(n - index)
